# ABAC Core Module — Research Findings

Generated by deep-plan research agents for `docs/plans/01-abac-core/spec.md`.

---

## 1. Authentication Architecture

### `src/auth/session.rs` — Permissions Struct

```rust
#[derive(Debug, Clone, Default)]
pub struct Permissions(pub Vec<String>);
```

- **Newtype wrapper** around `Vec<String>` — single public field `0`
- Derives: `Debug`, `Clone`, `Default` (empty vec by default)
- Key methods:

```rust
pub fn has(&self, code: &str) -> bool {
    self.0.iter().any(|p| p == code)
}

pub fn from_csv(csv: &str) -> Self {
    let codes = csv.split(',').map(|s| s.trim())
        .filter(|s| !s.is_empty()).map(String::from).collect();
    Permissions(codes)
}
```

- Session helpers: `get_user_id()`, `get_permissions()`, `require_permission()`
- `require_permission` returns `Err(AppError::PermissionDenied(code.to_string()))` on failure

### `src/auth/mod.rs` — Module Structure

```rust
pub mod csrf;
pub mod middleware;
pub mod password;
pub mod rate_limit;
pub mod session;
pub mod validate;
```

New `abac` module will be added as `pub mod abac;` here.

---

## 2. Test Infrastructure

### `tests/common/mod.rs` — `setup_test_db()`

```rust
pub fn setup_test_db() -> (TempDir, Connection) {
    let dir = TempDir::new().expect("...");
    let db_path = dir.path().join("test.db");
    let conn = rusqlite::Connection::open(&db_path).expect("...");
    conn.execute_batch("PRAGMA foreign_keys=ON; PRAGMA journal_mode=WAL;").expect("...");
    conn.execute_batch(MIGRATIONS).expect("...");
    seed_base_entities(&conn).expect("...");
    (dir, conn)
}
```

### Seeded Relation Types (from `seed_base_entities`)

All 11 types are seeded as `entity_type='relation_type'` entities:
```
"has_role", "has_permission", "requires_permission",
"belongs_to_tor", "fills_position", "participates_in",
"is_blocking", "transition_from", "transition_to",
"minutes_of", "section_of"
```

Both `"fills_position"` and `"belongs_to_tor"` are seeded — ABAC queries can use them immediately in test DBs without additional setup.

- Default role entity gets explicit `id = 0`
- TempDir isolation ensures parallel test safety

---

## 3. EAV Data Model

### Schema

```sql
entities (id, entity_type, name, label, sort_order, is_active, created_at, updated_at)
entity_properties (entity_id, key, value)  -- PRIMARY KEY (entity_id, key)
relations (id, relation_type_id, source_id, target_id)
```

- **`entity_properties.value`** is always TEXT — capabilities stored as `'true'`/`'false'` strings
- **ON DELETE CASCADE** on both entity_properties and relations
- **Indexes**: `idx_relations_source (source_id, relation_type_id)`, `idx_relations_target (target_id, relation_type_id)`

### Relation Type ID Resolution Pattern

The canonical approach (used throughout the codebase) is an **inline subquery** rather than a JOIN:

```sql
WHERE relation_type_id = (
    SELECT id FROM entities
    WHERE entity_type = 'relation_type' AND name = 'fills_position'
)
```

This pattern appears in `relation::create()`, `find_codes_by_user_id()`, vacancy generators, and EAV graph traversal throughout the codebase.

---

## 4. ABAC Design

### The EAV Graph Structure

```
user ──fills_position──> tor_function_entity ──belongs_to_tor──> tor_entity
                              │
                    entity_properties:
                      can_call_meetings    = 'true' | 'false'
                      can_manage_agenda    = 'true' | 'false'
                      can_record_decisions = 'true' | 'false'
                      can_review_suggestions  = 'true' | 'false'
                      can_create_proposals    = 'true' | 'false'
                      can_approve_proposals   = 'true' | 'false'
```

### Two-Phase Authorization Check

```
Phase 1: require_permission(session, "tor.edit") → Ok  ⇒  ALLOW (global bypass)
Phase 2: has_resource_capability(conn, user_id, tor_id,
           "belongs_to_tor", "can_call_meetings") → true  ⇒  ALLOW
                                                   → false ⇒  DENY
```

### SQL for `has_resource_capability`

```sql
SELECT COUNT(*)
FROM relations r_fills
JOIN relations r_belongs ON r_belongs.source_id = r_fills.target_id
JOIN entity_properties ep ON ep.entity_id = r_fills.target_id
WHERE r_fills.source_id = ?1                          -- user_id
  AND r_belongs.target_id = ?2                        -- resource_id (tor_id)
  AND r_fills.relation_type_id = (
      SELECT id FROM entities
      WHERE entity_type = 'relation_type' AND name = 'fills_position')
  AND r_belongs.relation_type_id = (
      SELECT id FROM entities
      WHERE entity_type = 'relation_type' AND name = ?3)  -- belongs_to_rel
  AND ep.key = ?4                                     -- capability
  AND ep.value = 'true'
```

### SQL for `load_tor_capabilities`

```sql
SELECT DISTINCT ep.key
FROM relations r_fills
JOIN relations r_tor ON r_tor.source_id = r_fills.target_id
JOIN entity_properties ep ON ep.entity_id = r_fills.target_id
WHERE r_fills.source_id = ?1                        -- user_id
  AND r_tor.target_id = ?2                          -- tor_id
  AND r_fills.relation_type_id = (
      SELECT id FROM entities
      WHERE entity_type = 'relation_type' AND name = 'fills_position')
  AND r_tor.relation_type_id = (
      SELECT id FROM entities
      WHERE entity_type = 'relation_type' AND name = 'belongs_to_tor')
  AND ep.key LIKE 'can_%'
  AND ep.value = 'true'
```

### Capability → Handler Mapping

| Capability | Handlers |
|---|---|
| `can_call_meetings` | `confirm`, `confirm_calendar`, `transition` |
| `can_manage_agenda` | `assign_agenda`, `remove_agenda` |
| `can_record_decisions` | `generate_minutes`, `save_roll_call`, `save_attendance`, `save_action_items` |

---

## 5. rusqlite 0.32 Query Patterns

### Parameter Syntax

The codebase uses `?N` positional syntax with `params![]`:
```rust
conn.query_row(
    "SELECT ... WHERE user_id = ?1 AND tor_id = ?2",
    params![user_id, tor_id],
    |row| row.get(0),
)?;
```

`?` and `?N` are equivalent in rusqlite — `params![a, b]` binds to `?1` and `?2`.

### `query_row` with `.optional()`

For existence checks that return 0 or 1 rows:
```rust
use rusqlite::OptionalExtension;
let result: Option<i64> = conn.query_row(
    "SELECT COUNT(*) FROM ... WHERE ...",
    params![user_id, tor_id, capability],
    |row| row.get(0),
).optional()?;
// Or just compare count > 0 directly
```

### `query_map` → `Vec<String>` Pattern

The canonical pattern for collecting multiple rows into a Vec (from `find_codes_by_user_id`):
```rust
let mut stmt = conn.prepare("SELECT DISTINCT ep.key FROM ...")?;
let keys = stmt
    .query_map(params![user_id, tor_id], |row| row.get::<_, String>(0))?
    .collect::<Result<Vec<_>, _>>()?;
Ok(Permissions(keys))
```

### COALESCE for nullable columns

Always use `COALESCE(col, default)` in LEFT JOIN queries — `row.get::<_, String>()` fails on NULL for non-Option types.

### Named-column access is preferred

```rust
row.get("column_name")?  // preferred, clear and safe
row.get(0)?              // ok for simple single-column queries
```

---

## 6. Complete Test Helpers (from Implementation Plan)

These are provided verbatim from the existing implementation plan and are ready to copy into `tests/abac_test.rs`:

```rust
fn create_function(conn: &rusqlite::Connection, name: &str, capability: &str, value: &str) -> i64 {
    conn.execute(
        "INSERT INTO entities (entity_type, name, label) VALUES ('tor_function', ?1, ?1)",
        [name],
    ).unwrap();
    let func_id: i64 = conn.query_row(
        "SELECT id FROM entities WHERE name = ?1 AND entity_type = 'tor_function'",
        [name],
        |r| r.get(0),
    ).unwrap();
    conn.execute(
        "INSERT INTO entity_properties (entity_id, key, value) VALUES (?1, ?2, ?3)",
        params![func_id, capability, value],
    ).unwrap();
    func_id
}

fn create_user(conn: &rusqlite::Connection, name: &str) -> i64 {
    conn.execute(
        "INSERT INTO entities (entity_type, name, label) VALUES ('user', ?1, ?1)",
        [name],
    ).unwrap();
    conn.query_row(
        "SELECT id FROM entities WHERE name = ?1 AND entity_type = 'user'",
        [name],
        |r| r.get(0),
    ).unwrap()
}

fn create_tor(conn: &rusqlite::Connection, name: &str) -> i64 {
    conn.execute(
        "INSERT INTO entities (entity_type, name, label) VALUES ('tor', ?1, ?1)",
        [name],
    ).unwrap();
    conn.query_row(
        "SELECT id FROM entities WHERE name = ?1 AND entity_type = 'tor'",
        [name],
        |r| r.get(0),
    ).unwrap()
}

fn rel_type(conn: &rusqlite::Connection, name: &str) -> i64 {
    conn.query_row(
        "SELECT id FROM entities WHERE entity_type = 'relation_type' AND name = ?1",
        [name],
        |r| r.get(0),
    ).unwrap()
}

fn fills_position(conn: &rusqlite::Connection, user_id: i64, func_id: i64) {
    let rt = rel_type(conn, "fills_position");
    conn.execute(
        "INSERT INTO relations (relation_type_id, source_id, target_id) VALUES (?1, ?2, ?3)",
        params![rt, user_id, func_id],
    ).unwrap();
}

fn belongs_to_tor(conn: &rusqlite::Connection, func_id: i64, tor_id: i64) {
    let rt = rel_type(conn, "belongs_to_tor");
    conn.execute(
        "INSERT INTO relations (relation_type_id, source_id, target_id) VALUES (?1, ?2, ?3)",
        params![rt, func_id, tor_id],
    ).unwrap();
}
```

---

## 7. Dependencies

From `Cargo.toml`:
```toml
rusqlite = { version = "0.32", features = ["bundled"] }
```

No additional features needed. `OptionalExtension` is available in `rusqlite::OptionalExtension`.

The `ahlt` crate exports auth module:
- Test imports: `use ahlt::auth::abac;`
- Handler imports: `use crate::auth::abac;`

---

## 8. Testing Approach

- Tests use `setup_test_db()` → TempDir isolation, safe for parallel execution
- `seed_base_entities()` provides both `fills_position` and `belongs_to_tor` relation types
- Test helpers create minimal entity graphs inline (no shared fixtures needed)
- Run: `cargo test --test abac_test`
- TDD order: write all 7 failing tests first, then implement until green

{% extends "base.html" %}

{% block title %}Meeting Outlook — {{ ctx.app_name }}{% endblock %}

{% block nav %}
{% include "partials/nav.html" %}
{% endblock %}

{% block sidebar %}
{% include "partials/sidebar.html" %}
{% endblock %}

{% block content %}
{% if let Some(msg) = ctx.flash %}
<div class="alert alert-success">{{ msg }}</div>
{% endif %}

<div class="page-header">
    <h1>Meeting Outlook</h1>
    <a href="/tor" class="btn btn-sm">All ToRs</a>
</div>

<div class="outlook-controls">
    <div class="outlook-nav">
        <button class="btn btn-sm" id="outlook-prev" title="Previous">&lsaquo; Prev</button>
        <button class="btn btn-sm" id="outlook-today">Today</button>
        <button class="btn btn-sm" id="outlook-next" title="Next">Next &rsaquo;</button>
    </div>
    <h2 class="outlook-title" id="outlook-title"></h2>
    <div class="outlook-tabs">
        <button class="outlook-tab" data-view="day">Day</button>
        <button class="outlook-tab active" data-view="week">Week</button>
        <button class="outlook-tab" data-view="month">Month</button>
    </div>
</div>

<input type="hidden" name="csrf_token" id="csrf_token" value="{{ ctx.csrf_token }}">
<div class="outlook-container" id="outlook-container">
    <div class="outlook-loading" id="outlook-loading" style="display:none;">
        <span>Loading&hellip;</span>
    </div>
</div>

<script>
(function() {
    var container = document.getElementById('outlook-container');
    var titleEl = document.getElementById('outlook-title');
    var loadingEl = document.getElementById('outlook-loading');

    // Color palette for ToRs (cycle through)
    var TOR_COLORS = [
        { bg: '#dbeafe', border: '#3b82f6', text: '#1e40af' },
        { bg: '#dcfce7', border: '#22c55e', text: '#166534' },
        { bg: '#fef3c7', border: '#f59e0b', text: '#92400e' },
        { bg: '#fce7f3', border: '#ec4899', text: '#9d174d' },
        { bg: '#e0e7ff', border: '#6366f1', text: '#3730a3' },
        { bg: '#f3e8ff', border: '#a855f7', text: '#6b21a8' },
        { bg: '#ccfbf1', border: '#14b8a6', text: '#115e59' },
        { bg: '#fee2e2', border: '#ef4444', text: '#991b1b' }
    ];
    var torColorMap = {};
    var nextColorIdx = 0;
    function torColor(torId) {
        if (!torColorMap[torId]) {
            torColorMap[torId] = TOR_COLORS[nextColorIdx % TOR_COLORS.length];
            nextColorIdx++;
        }
        return torColorMap[torId];
    }

    function el(tag, cls, text) {
        var e = document.createElement(tag);
        if (cls) e.className = cls;
        if (text) e.textContent = text;
        return e;
    }

    var TODAY = '{{ today }}';
    var currentView = 'week';
    var currentDate = parseDate('{{ week_start }}');
    var cachedEvents = JSON.parse('{{ events_json|safe }}');

    // Assign initial colors
    cachedEvents.forEach(function(e) { torColor(e.tor_id); });

    var FETCH_TIMEOUT_MS = 30000;

    function fetchWithTimeout(url, options, ms) {
        var controller = new AbortController();
        var timer = setTimeout(function() { controller.abort(); }, ms);
        var opts = Object.assign({}, options || {}, { signal: controller.signal });
        return fetch(url, opts).finally(function() { clearTimeout(timer); });
    }

    var DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June',
                  'July', 'August', 'September', 'October', 'November', 'December'];

    function parseDate(s) {
        var p = s.split('-');
        return new Date(+p[0], +p[1] - 1, +p[2]);
    }
    function fmtDate(d) {
        var y = d.getFullYear();
        var m = String(d.getMonth() + 1).padStart(2, '0');
        var dd = String(d.getDate()).padStart(2, '0');
        return y + '-' + m + '-' + dd;
    }
    function addDays(d, n) {
        var r = new Date(d);
        r.setDate(r.getDate() + n);
        return r;
    }
    function mondayOf(d) {
        var r = new Date(d);
        var day = r.getDay(); // 0=Sun
        var diff = day === 0 ? -6 : 1 - day;
        r.setDate(r.getDate() + diff);
        return r;
    }
    function firstOfMonth(d) {
        return new Date(d.getFullYear(), d.getMonth(), 1);
    }

    // Tab switching
    document.querySelectorAll('.outlook-tab').forEach(function(tab) {
        tab.addEventListener('click', function() {
            document.querySelectorAll('.outlook-tab').forEach(function(t) { t.classList.remove('active'); });
            tab.classList.add('active');
            currentView = tab.dataset.view;
            if (currentView === 'week') {
                currentDate = mondayOf(currentDate);
            } else if (currentView === 'month') {
                currentDate = firstOfMonth(currentDate);
            }
            fetchAndRender();
        });
    });

    // Navigation
    document.getElementById('outlook-prev').addEventListener('click', function() {
        if (currentView === 'day') currentDate = addDays(currentDate, -1);
        else if (currentView === 'week') currentDate = addDays(currentDate, -7);
        else currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() - 1, 1);
        fetchAndRender();
    });
    document.getElementById('outlook-next').addEventListener('click', function() {
        if (currentView === 'day') currentDate = addDays(currentDate, 1);
        else if (currentView === 'week') currentDate = addDays(currentDate, 7);
        else currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
        fetchAndRender();
    });
    document.getElementById('outlook-today').addEventListener('click', function() {
        currentDate = parseDate(TODAY);
        if (currentView === 'week') currentDate = mondayOf(currentDate);
        else if (currentView === 'month') currentDate = firstOfMonth(currentDate);
        fetchAndRender();
    });

    function fetchAndRender() {
        var start, end;
        if (currentView === 'day') {
            start = fmtDate(currentDate);
            end = start;
        } else if (currentView === 'week') {
            start = fmtDate(currentDate);
            end = fmtDate(addDays(currentDate, 6));
        } else {
            start = fmtDate(firstOfMonth(currentDate));
            var lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
            end = fmtDate(lastDay);
        }

        loadingEl.style.display = '';
        fetchWithTimeout('/api/tor/calendar?start=' + start + '&end=' + end, null, FETCH_TIMEOUT_MS)
            .then(function(r) { return r.json(); })
            .then(function(events) {
                loadingEl.style.display = 'none';
                events.forEach(function(e) { torColor(e.tor_id); });
                cachedEvents = events;
                render();
            })
            .catch(function(err) {
                loadingEl.style.display = 'none';
                if (err.name === 'AbortError') {
                    container.textContent = 'Request timed out. The server may be busy. Please try again.';
                } else {
                    container.textContent = 'Failed to load calendar data.';
                    console.error('Calendar fetch error:', err);
                }
            });
    }

    function updateTitle() {
        if (currentView === 'day') {
            titleEl.textContent = DAYS[(currentDate.getDay() + 6) % 7] + ' ' +
                currentDate.getDate() + ' ' + MONTHS[currentDate.getMonth()] + ' ' + currentDate.getFullYear();
        } else if (currentView === 'week') {
            var end = addDays(currentDate, 6);
            if (currentDate.getMonth() === end.getMonth()) {
                titleEl.textContent = currentDate.getDate() + '\u2013' + end.getDate() + ' ' +
                    MONTHS[currentDate.getMonth()] + ' ' + currentDate.getFullYear();
            } else {
                titleEl.textContent = currentDate.getDate() + ' ' + MONTHS[currentDate.getMonth()].substring(0, 3) +
                    ' \u2013 ' + end.getDate() + ' ' + MONTHS[end.getMonth()].substring(0, 3) + ' ' + end.getFullYear();
            }
        } else {
            titleEl.textContent = MONTHS[currentDate.getMonth()] + ' ' + currentDate.getFullYear();
        }
    }

    function render() {
        updateTitle();
        while (container.firstChild) container.removeChild(container.firstChild);
        if (currentView === 'week') renderWeek();
        else if (currentView === 'day') renderDay();
        else renderMonth();
    }

    function makePill(evt, showLoc) {
        var c = torColor(evt.tor_id);
        var slots = Math.max(1, Math.ceil(evt.duration_minutes / 30));
        var pill = document.createElement('div');
        pill.className = 'outlook-event';
        
        // Add status class for styling (projected vs confirmed)
        if (evt.meeting_status) {
            pill.classList.add('outlook-event--' + evt.meeting_status);
        }
        
        pill.style.backgroundColor = c.bg;
        pill.style.borderLeft = '3px solid ' + c.border;
        pill.style.color = c.text;
        pill.title = evt.tor_label + ' \\u00b7 ' + evt.start_time + ' \\u00b7 ' + evt.duration_minutes + 'min' +
            (evt.location ? ' \\u00b7 ' + evt.location : '');

        // Create wrapper for content (non-link part)
        var content = document.createElement('div');
        content.className = 'outlook-event-content';
        
        var link = document.createElement('a');
        link.href = '/tor/' + evt.tor_id;
        link.className = 'outlook-event-link';
        
        link.appendChild(el('span', 'outlook-event-time', evt.start_time));
        link.appendChild(document.createTextNode(' '));
        link.appendChild(el('span', 'outlook-event-label', evt.tor_label));
        if (showLoc && evt.location) {
            link.appendChild(document.createTextNode(' '));
            link.appendChild(el('span', 'outlook-event-loc', evt.location));
        }
        
        content.appendChild(link);
        pill.appendChild(content);
        
        // Add confirm badge for future unconfirmed meetings
        if (evt.date > TODAY && evt.meeting_status !== 'confirmed') {
            var badge = document.createElement('button');
            badge.type = 'button';
            badge.className = 'outlook-event-confirm-badge';
            badge.textContent = '\u2713';
            badge.title = 'Confirm this meeting';
            badge.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                confirmMeetingAjax(evt, pill, badge);
            });
            pill.appendChild(badge);
        }
        
        return { pill: pill, slots: slots };
    }
    
    function confirmMeetingAjax(evt, pill, badge) {
        var csrfToken = document.getElementById('csrf_token').value;
        badge.classList.add('outlook-event-confirm-badge--loading');
        badge.textContent = '\u22ef';  // ellipsis while loading

        var body = 'csrf_token=' + encodeURIComponent(csrfToken) +
                   '&meeting_date=' + encodeURIComponent(evt.date) +
                   '&tor_name=' + encodeURIComponent(evt.tor_label);
        if (evt.meeting_id) {
            body += '&meeting_id=' + encodeURIComponent(evt.meeting_id);
        }

        fetchWithTimeout('/api/tor/' + evt.tor_id + '/meetings/confirm-calendar', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: body,
            credentials: 'same-origin'
        }, FETCH_TIMEOUT_MS)
        .then(function(r) {
            if (!r.ok) { throw new Error('Server error ' + r.status); }
            return r.json();
        })
        .then(function(data) {
            if (!data.ok) { throw new Error(data.error || 'Unknown error'); }
            // Success: update pill in place
            pill.classList.remove('outlook-event--projected');
            pill.classList.add('outlook-event--confirmed');
            if (badge.parentNode) { badge.parentNode.removeChild(badge); }
        })
        .catch(function(err) {
            // Restore badge on error so user can retry
            badge.classList.remove('outlook-event-confirm-badge--loading');
            badge.textContent = '\u2713';

            if (err.name === 'AbortError') {
                badge.title = 'Request timed out. Click to retry.';
            }
            console.error('Failed to confirm meeting:', err);
        });
    }

    // --- WEEK VIEW ---
    function renderWeek() {
        var grid = el('div', 'outlook-week-grid');

        // Header row
        grid.appendChild(el('div', 'outlook-time-header'));
        for (var col = 0; col < 7; col++) {
            var d = addDays(currentDate, col);
            var hdr = el('div', 'outlook-day-header');
            if (fmtDate(d) === TODAY) hdr.classList.add('outlook-today');
            hdr.appendChild(el('span', 'outlook-day-name', DAYS[col]));
            hdr.appendChild(el('span', 'outlook-day-num', String(d.getDate())));
            grid.appendChild(hdr);
        }

        // Time rows 07:00 - 19:00
        for (var hour = 7; hour < 19; hour++) {
            for (var half = 0; half < 2; half++) {
                var timeStr = String(hour).padStart(2, '0') + ':' + (half === 0 ? '00' : '30');
                var timeCell = el('div', 'outlook-time-label');
                if (half === 0) timeCell.textContent = timeStr;
                grid.appendChild(timeCell);

                for (var c2 = 0; c2 < 7; c2++) {
                    var cell = el('div', 'outlook-cell');
                    if (half === 0) cell.classList.add('outlook-cell-hour');
                    var dateStr = fmtDate(addDays(currentDate, c2));
                    if (dateStr === TODAY) cell.classList.add('outlook-today-col');
                    cell.dataset.date = dateStr;
                    cell.dataset.time = timeStr;
                    grid.appendChild(cell);
                }
            }
        }

        container.appendChild(grid);
        placeWeekEvents(grid);
    }

    function placeWeekEvents(grid) {
        cachedEvents.forEach(function(evt) {
            var parts = evt.start_time.split(':');
            var evtHour = parseInt(parts[0], 10);
            var evtMin = parseInt(parts[1], 10);
            if (evtHour < 7 || evtHour >= 19) return;

            var d = parseDate(evt.date);
            var col = (d.getDay() + 6) % 7; // Mon=0
            var rowOffset = (evtHour - 7) * 2 + (evtMin >= 30 ? 1 : 0);

            var cells = grid.querySelectorAll('.outlook-cell');
            var idx = rowOffset * 7 + col;
            if (idx >= cells.length) return;

            var p = makePill(evt, false);
            p.pill.style.height = (p.slots * 100) + '%';
            cells[idx].appendChild(p.pill);
        });
    }

    // --- DAY VIEW ---
    var DAY_SLOT_HEIGHT = 28; // px per 30-min slot

    // Compute overlap columns for a list of events with startMin/endMin fields.
    // Returns array of { evt, col, totalCols } where col is 0-based column index.
    function computeOverlapColumns(events) {
        if (!events.length) return [];

        // Sort by start time, then by duration descending (longer events first)
        events.sort(function(a, b) {
            return a.startMin - b.startMin || b.endMin - a.endMin;
        });

        // Greedy column assignment: for each event, find the first column
        // where it doesn't overlap with any already-placed event.
        var placed = []; // { startMin, endMin, col }
        events.forEach(function(item) {
            // Find columns occupied by overlapping events
            var usedCols = {};
            placed.forEach(function(p) {
                if (p.startMin < item.endMin && p.endMin > item.startMin) {
                    usedCols[p.col] = true;
                }
            });
            // Assign first free column
            var col = 0;
            while (usedCols[col]) col++;
            item.col = col;
            placed.push({ startMin: item.startMin, endMin: item.endMin, col: col });
        });

        // Compute total columns per overlap group using a connected-components approach.
        // Two events are in the same group if they overlap (directly or transitively).
        // Track by event index (not column) to avoid false grouping of non-overlapping
        // events that happen to share the same column number.
        events.forEach(function(item, idx) {
            var inGroup = {};
            inGroup[idx] = true;
            var changed = true;
            while (changed) {
                changed = false;
                events.forEach(function(other, oi) {
                    if (inGroup[oi]) return; // already in group
                    // Check if 'other' overlaps with any event in the group
                    events.forEach(function(member, mi) {
                        if (!inGroup[mi]) return;
                        if (member.startMin < other.endMin && member.endMin > other.startMin) {
                            inGroup[oi] = true;
                            changed = true;
                        }
                    });
                });
            }
            // totalCols = number of distinct columns used by events in this group
            var groupCols = {};
            Object.keys(inGroup).forEach(function(k) { groupCols[events[k].col] = true; });
            item.totalCols = Object.keys(groupCols).length;
        });

        return events;
    }

    function renderDay() {
        var grid = el('div', 'outlook-day-grid');
        var dateStr = fmtDate(currentDate);
        var FIRST_HOUR = 7;
        var LAST_HOUR = 19;

        // Build the time grid rows
        for (var hour = FIRST_HOUR; hour < LAST_HOUR; hour++) {
            for (var half = 0; half < 2; half++) {
                var timeStr = String(hour).padStart(2, '0') + ':' + (half === 0 ? '00' : '30');
                var row = el('div', 'outlook-day-row');
                if (half === 0) row.classList.add('outlook-day-row-hour');

                var label = el('div', 'outlook-time-label');
                if (half === 0) label.textContent = timeStr;
                row.appendChild(label);

                var cell = el('div', 'outlook-day-cell');
                if (dateStr === TODAY) cell.classList.add('outlook-today-col');
                row.appendChild(cell);
                grid.appendChild(row);
            }
        }

        container.appendChild(grid);

        // Collect events for this day with computed positions
        var dayEvents = [];
        cachedEvents.forEach(function(evt) {
            if (evt.date !== dateStr) return;
            var parts = evt.start_time.split(':');
            var evtHour = parseInt(parts[0], 10);
            var evtMinute = parseInt(parts[1], 10);
            if (evtHour < FIRST_HOUR || evtHour >= LAST_HOUR) return;

            var startMin = (evtHour - FIRST_HOUR) * 60 + evtMinute;
            var endMin = startMin + (evt.duration_minutes || 30);
            dayEvents.push({ evt: evt, startMin: startMin, endMin: endMin });
        });

        if (!dayEvents.length) return;

        // Compute overlap columns
        computeOverlapColumns(dayEvents);

        // Get all day cells for absolute positioning
        var dayCells = grid.querySelectorAll('.outlook-day-cell');

        // Place events absolutely within their starting cell's row
        dayEvents.forEach(function(item) {
            var evt = item.evt;
            var slotIndex = Math.floor(item.startMin / 30);
            if (slotIndex >= dayCells.length) return;

            var targetCell = dayCells[slotIndex];
            var p = makePill(evt, true);
            p.pill.classList.add('outlook-event-day');

            // Compute pixel offset within the slot (for events not starting on a 30-min boundary)
            var offsetInSlot = item.startMin % 30;
            var topPx = Math.round(offsetInSlot * DAY_SLOT_HEIGHT / 30);
            var heightPx = Math.round((item.endMin - item.startMin) * DAY_SLOT_HEIGHT / 30) - 2;
            p.pill.style.height = Math.max(heightPx, 20) + 'px';

            // Apply overlap positioning
            if (item.totalCols > 1) {
                p.pill.style.position = 'absolute';
                p.pill.style.top = topPx + 'px';
                var widthPct = 100 / item.totalCols;
                p.pill.style.left = (item.col * widthPct) + '%';
                p.pill.style.width = widthPct + '%';
                p.pill.style.boxSizing = 'border-box';
                p.pill.style.zIndex = String(item.col + 1);
            } else {
                // No overlap — full width, flow-based
                if (topPx > 0) p.pill.style.marginTop = topPx + 'px';
            }

            var dur = el('span', 'outlook-event-dur', evt.duration_minutes + 'min');
            p.pill.appendChild(document.createTextNode(' '));
            p.pill.appendChild(dur);
            targetCell.appendChild(p.pill);
        });
    }

    // --- MONTH VIEW ---
    function renderMonth() {
        var grid = el('div', 'outlook-month-grid');

        // Header row
        for (var i = 0; i < 7; i++) {
            grid.appendChild(el('div', 'outlook-month-header', DAYS[i]));
        }

        var first = firstOfMonth(currentDate);
        var startCol = (first.getDay() + 6) % 7; // Mon=0
        var lastDay = new Date(first.getFullYear(), first.getMonth() + 1, 0).getDate();

        // Index events by date
        var eventsByDate = {};
        cachedEvents.forEach(function(e) {
            if (!eventsByDate[e.date]) eventsByDate[e.date] = [];
            eventsByDate[e.date].push(e);
        });

        // Leading blanks
        for (var b = 0; b < startCol; b++) {
            grid.appendChild(el('div', 'outlook-month-cell outlook-month-blank'));
        }

        for (var day = 1; day <= lastDay; day++) {
            var d = new Date(first.getFullYear(), first.getMonth(), day);
            var ds = fmtDate(d);
            var cell = el('div', 'outlook-month-cell');
            if (ds === TODAY) cell.classList.add('outlook-today');

            cell.appendChild(el('span', 'outlook-month-num', String(day)));

            var dayEvents = eventsByDate[ds] || [];
            dayEvents.forEach(function(evt) {
                var c = torColor(evt.tor_id);
                var dot = document.createElement('a');
                dot.href = '/tor/' + evt.tor_id;
                dot.className = 'outlook-month-event';
                dot.style.backgroundColor = c.bg;
                dot.style.borderLeft = '2px solid ' + c.border;
                dot.style.color = c.text;
                dot.textContent = evt.start_time + ' ' + evt.tor_label;
                dot.title = evt.tor_label + ' \u00b7 ' + evt.start_time + ' \u00b7 ' + evt.duration_minutes + 'min';
                cell.appendChild(dot);
            });

            grid.appendChild(cell);
        }

        // Trailing blanks
        var total = startCol + lastDay;
        var trailing = (7 - (total % 7)) % 7;
        for (var t = 0; t < trailing; t++) {
            grid.appendChild(el('div', 'outlook-month-cell outlook-month-blank'));
        }

        container.appendChild(grid);
    }

    // Initial render
    render();
})();
</script>
{% endblock %}
